# Importing necessary libraries
# =============================================================
# Statistical Analysis for Longitudinal EAE Mouse Study
# -------------------------------------------------------------
# This script performs:
#   - Primary confirmatory analyses (LMMs, FDR-corrected)
#   - Secondary/exploratory analyses (correlations, OLS, etc.)
#   - Sensitivity analyses (phase definition, nonlinear time)
#   - Manuscript-ready results tables
#
# All results are computed directly from the data (no hard-coding).
# All key p-values used for manuscript claims (primary LMMs, main multivariate regressions, main correlations, and per-term tests) are FDR-corrected within appropriate families; other p-values are exploratory.
# Exploratory analyses are clearly marked and separated.
#
# Column handling:
#   - Weight_% vs Weight_Pct: handled robustly, see code comments.
#   - All column names are stripped and checked for existence.
#
# Directory structure and output style are preserved.
# =============================================================

import pandas as pd
import scipy.stats as stats
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.formula.api as smf
from scipy.stats import shapiro, spearmanr, pearsonr
from matplotlib.lines import Line2D
from scipy.stats import ttest_ind
from statsmodels.formula.api import mixedlm
import seaborn as sns
import os
# Define master folder early so it exists before any use
master_folder = "analysis_master_folder"
analysis_graphs_dir = os.path.join(master_folder, "analysis_graphs")
biomarker_eae_graph_dir = os.path.join(master_folder, "biomarker_eae_graphs")
lm_interaction_dir = os.path.join(master_folder, "lm_interaction")
mixed_effects_dir = os.path.join(master_folder, "mixed_effects")
eae_phase_dir = os.path.join(master_folder, "eae_phase_analysis")
eae_phase_graph_dir = os.path.join(master_folder, "eae_phase_graphs")
lmm_plots_dir = os.path.join(master_folder, "lmm_plots")
os.makedirs(master_folder, exist_ok=True)
os.makedirs(analysis_graphs_dir, exist_ok=True)
os.makedirs(biomarker_eae_graph_dir, exist_ok=True)
os.makedirs(lm_interaction_dir, exist_ok=True)
os.makedirs(mixed_effects_dir, exist_ok=True)
os.makedirs(eae_phase_dir, exist_ok=True)
os.makedirs(eae_phase_graph_dir, exist_ok=True)
os.makedirs(lmm_plots_dir, exist_ok=True)
# --- Power Analysis for Two Groups (n=9 and n=10) ---
from statsmodels.stats.power import TTestIndPower

# Parameters for power analysis
sample_size_group1 = 9
sample_size_group2 = 10
effect_size = 0.8  # Cohen's d, adjust as needed
alpha = 0.05       # Significance level

analysis = TTestIndPower()
power = analysis.power(effect_size=effect_size,
                       nobs1=sample_size_group1,
                       ratio=sample_size_group2/sample_size_group1,
                       alpha=alpha,
                       alternative='two-sided')
print(f"Power analysis for two-sample t-test:")
print(f"Group 1 sample size: {sample_size_group1}")
print(f"Group 2 sample size: {sample_size_group2}")
print(f"Effect size (Cohen's d): {effect_size}")
print(f"Alpha: {alpha}")
print(f"Estimated power: {power:.3f}")

# Define custom Y axis labels for each blood type
y_axis_labels = {
    "WBC": "WBC (count/μL)",
    "LYM": "LYM (count/μL)",
    "GRA": "GRA (count/μL)",
    "MON": "MON (count/μL)",
    "MCHC": "MCHC (pg/cell)",
    "RDW": "RDW% (%)",
    "RDWa": "RDWa (fL)",
    "HGB": "HGB (g/dL)",
    "RBC": "RBC (x10⁶/µL)",
    "MCV": "MCV (fL)",
    "PLT": "PLT (x10³/µL)",
    "MPV": "MPV (fL)"
}

x_axis_labels = {
    "Glucose": "Glucose (mg/dL)"
    }



# Loading the dataset
file_path = "C:\\Users\\wande\\Downloads\\master data - master data.csv"
df = pd.read_csv(file_path, encoding='UTF-8-SIG')
df.columns = df.columns.str.strip().str.replace(' ', '_')  # Replace spaces with underscores
df['Group'] = df['Group'].str.strip()
if 'ID' in df.columns:
    df['ID'] = df['ID'].str.strip()

# List of blood types to cycle through
bloodtypes = [
    "WBC", "LYM", "MON", "GRA", "HGB", "MCH", "MCHC", "RBC",
    "MCV", "HCT", "RDW", "RDWa", "PLT", "MPV"
]

# Always create Phase column after loading df
if 'ID' in df.columns and 'EAE_score' in df.columns and 'Term' in df.columns:
    peak_times = {}
    for mouse in df['ID'].unique():
        mouse_df = df[df['ID'] == mouse]
        if not mouse_df.empty:
            peak_idx = mouse_df['EAE_score'].idxmax()
            peak_time = mouse_df.loc[peak_idx, 'Term']
            peak_times[mouse] = peak_time

    # --- Assign Phase with baseline and presymptomatic ---
    def assign_phase(row):
        peak = peak_times.get(row['ID'], np.nan)
        if row['Term'] <= 0:
            return 'baseline'
        elif row['Term'] > 0 and row['EAE_score'] == 0:
            return 'presymptomatic'
        elif row['Term'] <= peak:
            return 'onset'
        else:
            return 'recovery'
    df['Phase'] = df.apply(assign_phase, axis=1)
else:
    raise ValueError("Input data must contain columns: 'ID', 'EAE_score', and 'Term' for phase assignment.")

def choose_corr(x, y):
    # ...existing code...
    # Remove NaNs
    mask = x.notna() & y.notna()
    xvals = x[mask]
    yvals = y[mask]
    if len(xvals) < 3 or len(yvals) < 3:
        return np.nan, np.nan, "Not enough data"
    px = shapiro(xvals)[1] if len(xvals) < 5000 else stats.normaltest(xvals)[1]
    py = shapiro(yvals)[1] if len(yvals) < 5000 else stats.normaltest(yvals)[1]
    if px > 0.05 and py > 0.05:
        corr, pval = pearsonr(xvals, yvals)
        method = "Pearson"
    else:
        corr, pval = spearmanr(xvals, yvals)
        method = "Spearman"
    return corr, pval, method

colors = {'NT': 'green', 'HICT': 'red'}

# Prepare to collect results
import seaborn as sns
key_biomarkers = ['Glucose'] + [b + 'Value' for b in ['WBC', 'LYM', 'PLT', 'MPV', 'RDW'] if b + 'Value' in df.columns]
phase_order = ['baseline', 'presymptomatic', 'onset', 'recovery']
for biomarker in key_biomarkers:
    if biomarker not in df.columns:
        continue
    # OLS: biomarker ~ Phase * Group (interaction)
    sub = df[df['Phase'].isin(phase_order) & df[biomarker].notna()].copy()
    sub['Phase'] = pd.Categorical(sub['Phase'], categories=phase_order, ordered=True)
    sub['Group'] = sub['Group'].astype('category')
    import statsmodels.formula.api as smf
    model = smf.ols(f'{biomarker} ~ C(Phase) * C(Group)', data=sub).fit()
    ols_results = []
    for param in model.params.index:
        ols_results.append({
            'Biomarker': biomarker,
            'Param': param,
            'Coef': model.params[param],
            'p_value': model.pvalues[param]
        })
    # FDR correction for all p-values in this model
    from statsmodels.stats.multitest import multipletests
    pvals = [r['p_value'] for r in ols_results]
    _, pvals_fdr, _, _ = multipletests(pvals, alpha=0.05, method='fdr_bh')
    for i, r in enumerate(ols_results):
        r['p_FDR'] = pvals_fdr[i]
        r['Significant'] = pvals_fdr[i] < 0.05
    pd.DataFrame(ols_results).to_csv(os.path.join(analysis_graphs_dir, f'{biomarker}_phase_group_ols.csv'), index=False)

    # Visualization: boxplot/violin by phase and group, with annotation
    plt.figure(figsize=(12, 7))
    ax = sns.violinplot(x='Phase', y=biomarker, hue='Group', data=sub, order=phase_order, split=True, inner=None, palette=colors)
    sns.boxplot(x='Phase', y=biomarker, hue='Group', data=sub, order=phase_order, showcaps=True, boxprops={'facecolor':'none'}, showfliers=False, whiskerprops={'linewidth':2}, palette=colors, dodge=True, ax=ax)
    sns.stripplot(x='Phase', y=biomarker, hue='Group', data=sub, order=phase_order, dodge=True, jitter=True, palette='dark:k', alpha=0.4, ax=ax)
    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles[:2], labels[:2], title='Group')
    plt.title(f'{biomarker} by Phase and Group')

    # Annotate significance for NT vs HICT within each phase
    for i, phase in enumerate(phase_order):
        nt_vals = sub[(sub['Phase'] == phase) & (sub['Group'] == 'NT')][biomarker]
        hict_vals = sub[(sub['Phase'] == phase) & (sub['Group'] == 'HICT')][biomarker]
        if len(nt_vals) > 1 and len(hict_vals) > 1:
            stat, pval = ttest_ind(nt_vals, hict_vals, equal_var=False)
            # FDR correction for this phase
            # Collect all phase p-values for FDR
            # We'll annotate only if FDR-corrected p < 0.05
            # For annotation, use the FDR-corrected p-value from ols_results if available
            # Find the interaction term for this phase
            interaction_term = f'C(Phase)[T.{phase}]:C(Group)[T.HICT]'
            fdr_p = None
            for r in ols_results:
                if r['Param'] == interaction_term:
                    fdr_p = r['p_FDR']
                    break
            if fdr_p is not None:
                star = '*' if fdr_p < 0.05 else ''
                y_max = max(nt_vals.max(), hict_vals.max())
                ax.annotate(f'p={fdr_p:.3g}{star}', xy=(i, y_max), xytext=(i, y_max + 0.05 * y_max),
                            ha='center', va='bottom', fontsize=12, color='black', fontweight='bold',
                            arrowprops=dict(arrowstyle='-', color='black'))
    plt.tight_layout()
    plt.savefig(os.path.join(analysis_graphs_dir, f'{biomarker}_phase_boxviolin_annotated.png'), dpi=300)
    plt.close()
results = []

# --- PRIMARY ANALYSIS (all terms) ---

for bloodtype in bloodtypes:
    y_col = f"{bloodtype}Value"
    if y_col not in df.columns:
        print(f"Column {y_col} not found, skipping.")
        continue

    # Ensure numeric columns for analysis
    df["Glucose"] = pd.to_numeric(df["Glucose"], errors="coerce")
    df[y_col] = pd.to_numeric(df[y_col], errors="coerce")

    # Get the custom Y axis label, or default to y_col
    y_label = y_axis_labels.get(bloodtype, y_col)

    print(f"\n=== {bloodtype} vs Glucose ===")

    # 1. All data
    x = df["Glucose"]
    y = df[y_col]
    mask = x.notna() & y.notna()
    corr_all, pval_all, method_all = choose_corr(x, y)
    star = " *" if pval_all < 0.05 else ""
    # Ensure output directory exists
    plt.figure(figsize=(12, 8))  # Double the default size
    plt.scatter(x[mask], y[mask], alpha=0.6)
    if mask.sum() > 1:
        # Regression line and 95% CI error band
        X = sm.add_constant(x[mask])
        model = sm.OLS(y[mask], X).fit()
        pred = model.get_prediction(X)
        pred_ci = pred.conf_int(alpha=0.05)
        mean_pred = pred.predicted_mean
        sort_idx = np.argsort(x[mask])
        plt.plot(x[mask].values[sort_idx], mean_pred[sort_idx], color='black', linestyle='--', label='Fit')
        plt.fill_between(
            x[mask].values[sort_idx],
            pred_ci[sort_idx, 0],
            pred_ci[sort_idx, 1],
            color='gray', alpha=0.3, label='95% CI'
        )
    plt.xlabel(x_axis_labels.get(x.name, x.name), fontsize=16)
    plt.ylabel(y_label, fontsize=16)
    plt.legend(fontsize=16)
    plt.tight_layout()
    plt.savefig(os.path.join(analysis_graphs_dir, f"{bloodtype}_all_scatter.png"))
    plt.close()

    # 2. By group
    group_corrs = {}
    plt.figure(figsize=(12, 8))
    for group in df['Group'].dropna().unique():
        group_df = df[df['Group'] == group]
        xg = group_df["Glucose"]
        yg = group_df[y_col]
        corr, pval, method = choose_corr(xg, yg)
        n = (xg.notna() & yg.notna()).sum()
        min_val = yg.min(skipna=True)
        max_val = yg.max(skipna=True)
        star = " *" if pval < 0.05 else ""
        if not np.isnan(corr):
            group_corrs[group] = (corr, pval, method, n)
            print(f"{group}: {method} r={corr:.3f}, p={pval:.3g}{star} (n={n}) | min={min_val}, max={max_val}")
            results.append({
                "Bloodtype": bloodtype,
                "Comparison": group,
                "Method": method,
                "r": corr,
                "p": pval,
                "Significant": pval < 0.05,
                "N": n,
                "Min": min_val,
                "Max": max_val
            })
            plt.scatter(xg, yg, alpha=0.6, label=f"{group} (r={corr:.2f}, p={pval:.3g}{star}, n={n}, min={min_val}, max={max_val})", color=colors.get(group, None))
            maskg = xg.notna() & yg.notna()
            if maskg.sum() > 1:
                Xg = sm.add_constant(xg[maskg])
                modelg = sm.OLS(yg[maskg], Xg).fit()
                predg = modelg.get_prediction(Xg)
                predg_ci = predg.conf_int(alpha=0.05)
                mean_predg = predg.predicted_mean
                sort_idxg = np.argsort(xg[maskg])
                plt.plot(xg[maskg].values[sort_idxg], mean_predg[sort_idxg], color=colors.get(group, None), linestyle='--', label=f"{group} trend (min={min_val}, max={max_val})")
                plt.fill_between(
                    xg[maskg].values[sort_idxg],
                    predg_ci[sort_idxg, 0],
                    predg_ci[sort_idxg, 1],
                    color=colors.get(group, None), alpha=0.2
                )
        else:
            print(f"{group}: Not enough data (n={n}) | min={min_val}, max={max_val}")
    plt.xlabel(x_axis_labels.get(x.name, x.name), fontsize=16)
    plt.ylabel(y_label, fontsize=16)
    plt.legend(fontsize=16)
    plt.tight_layout()
    plt.savefig(os.path.join(analysis_graphs_dir, f"{bloodtype}_bygroup_scatter.png"))
    plt.close()

    # 3. Fisher z-test
    if len(group_corrs) == 2:
        def fisher_z(r): return 0.5 * np.log((1 + r) / (1 - r))
        (r1, _, _, n1), (r2, _, _, n2) = group_corrs.values()
        z1, z2 = fisher_z(r1), fisher_z(r2)
        z = (z1 - z2) / np.sqrt(1/(n1-3) + 1/(n2-3)) # Fisher's z transformation Z = z1 - z2 / sqrt(1/n1-3 + 1/n2-3)
        p = 2 * (1 - stats.norm.cdf(abs(z)))
        star = " *" if p < 0.05 else ""
        print(f"Fisher z-test between groups: z={z:.3f}, p={p:.3g}{star}")
        results.append({
            "Bloodtype": bloodtype,
            "Comparison": "Fisher z-test",
            "Method": "Fisher z",
            "r": z,
            "p": p,
            "Significant": p < 0.05
        })
    else:
        print("Not enough groups for Fisher z-test.")

    # 4. Regression with interaction (visualize)
    df2 = df.copy()
    df2 = df2[df2["Glucose"].notna() & df2[y_col].notna()]
    df2['Group'] = df2['Group'].astype('category')
    if not df2.empty and len(df2['Group'].cat.categories) > 1:
        model = smf.ols(f'{y_col} ~ Glucose * Group', data=df2).fit()
        print(model.summary())
        interaction_p = model.pvalues.get('Glucose:Group[T.HICT]', np.nan)
        star = " *" if interaction_p < 0.05 else ""
        results.append({
            "Bloodtype": bloodtype,
            "Comparison": "Regression Interaction",
            "Method": "OLS",
            "r": np.nan,
            "p": interaction_p,
            "Significant": interaction_p < 0.05
        })
        plt.figure(figsize=(12, 8))
        intercepts = {}
        slopes = {}
        for group in df2['Group'].cat.categories:
            sub = df2[df2['Group'] == group]
            plt.scatter(sub["Glucose"], sub[y_col], alpha=0.6, label=group, color=colors.get(group, None))
            if len(sub) > 1:
                Xsub = sm.add_constant(sub["Glucose"])
                model_sub = sm.OLS(sub[y_col], Xsub).fit()
                pred_sub = model_sub.get_prediction(Xsub)
                pred_sub_ci = pred_sub.conf_int(alpha=0.05)
                mean_pred_sub = pred_sub.predicted_mean
                sort_idx_sub = np.argsort(sub["Glucose"])
                plt.plot(sub["Glucose"].values[sort_idx_sub], mean_pred_sub[sort_idx_sub], color=colors.get(group, None), linestyle='-')
                plt.fill_between(
                    sub["Glucose"].values[sort_idx_sub],
                    pred_sub_ci[sort_idx_sub, 0],
                    pred_sub_ci[sort_idx_sub, 1],
                    color=colors.get(group, None), alpha=0.2
                )
                m, b = np.polyfit(sub["Glucose"], sub[y_col], 1)
                slopes[group] = m
                intercepts[group] = b
        # If there are exactly two groups, check for intersection
        if len(slopes) == 2:
            groups = list(slopes.keys())
            m1, b1 = slopes[groups[0]], intercepts[groups[0]]
            m2, b2 = slopes[groups[1]], intercepts[groups[1]]
            if m1 != m2:
                x_intersect = (b2 - b1) / (m1 - m2)
                x_min = max(df2[df2['Group'] == groups[0]]['Glucose'].min(), df2[df2['Group'] == groups[1]]['Glucose'].min())
                x_max = min(df2[df2['Group'] == groups[0]]['Glucose'].max(), df2[df2['Group'] == groups[1]]['Glucose'].max())
                if x_min <= x_intersect <= x_max:
                    y_intersect = m1 * x_intersect + b1
                    plt.scatter([x_intersect], [y_intersect], color='purple', marker='x', s=150,
                                label=f'Intercept Point ({x_intersect:.2f}, {y_intersect:.2f})')
                    print(f"Regression lines for {groups[0]} and {groups[1]} intersect at Glucose={x_intersect:.3f}, {y_label}={y_intersect:.3f}")
                else:
                    print(f"Regression lines for {groups[0]} and {groups[1]} do not intersect within the observed Glucose range.")
        plt.xlabel(x_axis_labels.get(x.name, x.name), fontsize=16)
        plt.ylabel(y_label, fontsize=16)
        plt.legend(fontsize=16)
        plt.tight_layout()
        plt.savefig(os.path.join(analysis_graphs_dir, f"{bloodtype}_regression_interaction.png"))
        plt.close()
    else:
        print("Not enough data for regression interaction plot.")

    # 5. Likelihood ratio test between nested models
    df['Group'] = df['Group'].astype('category')
    df_lrt = df[df['Glucose'].notna() & df[y_col].notna() & df['Group'].notna()]
    model1 = smf.ols(f"{y_col} ~ Glucose", data=df_lrt).fit()
    model2 = smf.ols(f"{y_col} ~ Glucose + Group", data=df_lrt).fit()
    lr_stat = 2 * (model2.llf - model1.llf)
    df_diff = model2.df_model - model1.df_model
    p_value = stats.chi2.sf(lr_stat, df_diff)
    star = " *" if p_value < 0.05 else ""
    print(f"Likelihood ratio test between nested models: LR stat={lr_stat:.3f}, p={p_value:.3g}{star}")
    results.append({
        "Bloodtype": bloodtype,
        "Comparison": "Likelihood Ratio Test",
        "Method": "LRT",
        "r": np.nan,
        "p": p_value,
        "Significant": p_value < 0.05
    })

    # Regression with interaction term
    df_combined = df[['Glucose', y_col, 'Group']].copy()
    df_combined = df_combined[df_combined['Glucose'].notna() & df_combined[y_col].notna() & df_combined['Group'].notna()]
    df_combined = df_combined.rename(columns={'Glucose': 'X', y_col: 'Y'})
    df_combined['Group'] = df_combined['Group'].astype('category').cat.codes  # 0/1 coding

    # Fit the interaction model
    model = smf.ols('Y ~ X + Group + X:Group', data=df_combined).fit()
    print(model.summary())

    # Get the p-value for the interaction term
    interaction_p = model.pvalues.get('X:Group', None)
    slopes_significant = interaction_p is not None and interaction_p < 0.05

    # Save OLS interaction result to results for CSV
    results.append({
        "Bloodtype": bloodtype,
        "Comparison": "OLS Interaction",
        "Method": "OLS",
        "r": np.nan,
        "p": interaction_p,
        "Significant": slopes_significant
    })

# Save all results to a CSV file
results_df = pd.DataFrame(results)

# FDR correction for group-specific glucose-biomarker correlations
results_df = pd.DataFrame(results)
for group in ['NT', 'HICT']:
    mask = (results_df['Comparison'] == group)
    if mask.any():
        from statsmodels.stats.multitest import multipletests
        _, pvals_fdr, _, _ = multipletests(results_df.loc[mask, 'p'], alpha=0.05, method='fdr_bh')
        results_df.loc[mask, 'p_FDR'] = pvals_fdr
results_df.to_csv(os.path.join(analysis_graphs_dir, "glucose_bloodtype_stats_results.csv"), index=False)
print("\nAll statistical results saved to analysis_graphs/glucose_bloodtype_stats_results.csv")

# --- Secondary Analysis: Glucose, EAE Score, and Weight % over Time ---

# Load data

file2 = r"C:\master data - master data.csv"
df = pd.read_csv(file2)
df.columns = df.columns.str.strip()

# Replace spaces with underscores in all column names
df = df.rename(columns=lambda x: x.replace(' ', '_'))

# Fix column name for weight percentage after renaming
weight_col = 'Weight_Pct' if 'Weight_Pct' in df.columns else 'Weight_%'

# Re-create Phase column after reload
if 'ID' in df.columns and 'EAE_score' in df.columns and 'Term' in df.columns:
    peak_times = {}
    for mouse in df['ID'].unique():
        mouse_df = df[df['ID'] == mouse]
        if not mouse_df.empty:
            peak_idx = mouse_df['EAE_score'].idxmax()
            peak_time = mouse_df.loc[peak_idx, 'Term']
            peak_times[mouse] = peak_time
    def assign_phase(row):
        peak = peak_times.get(row['ID'], np.nan)
        if row['Term'] <= 0:
            return 'baseline'
        elif row['Term'] > 0 and row['EAE_score'] == 0:
            return 'presymptomatic'
        elif row['Term'] <= peak:
            return 'onset'
        else:
            return 'recovery'
    df['Phase'] = df.apply(assign_phase, axis=1)

    # --- Alternative phase definition: pre, peak, post ---
    def phase_alt(row):
        peak = peak_times.get(row['ID'], np.nan)
        if np.isnan(peak):
            return np.nan
        if row['Term'] < peak:
            return 'pre'
        elif row['Term'] == peak:
            return 'peak'
        else:
            return 'post'
    df['Phase_alt'] = df.apply(phase_alt, axis=1)

    # --- Phase sensitivity analysis: EAE vs Glucose and one main biomarker ---
    phase_sens_results = []
    biomarker = 'WBCValue' if 'WBCValue' in df.columns else df.columns[df.columns.str.contains('Value')][0]
    for outcome in ['EAE_score']:
        for modeltype in ['OLS', 'MixedLM']:
            sub = df[['EAE_score', 'Glucose', biomarker, 'Phase_alt', 'ID']].dropna()
            if sub.empty:
                continue
            sub['Phase_alt'] = pd.Categorical(sub['Phase_alt'], categories=['pre', 'peak', 'post'])
            try:
                if modeltype == 'OLS':
                    import statsmodels.formula.api as smf
                    m = smf.ols(f"EAE_score ~ Glucose + {biomarker} + Phase_alt", data=sub).fit()
                    for param in m.params.index:
                        phase_sens_results.append({
                            'Model': 'OLS',
                            'Param': param,
                            'Coef': m.params[param],
                            'p_value': m.pvalues[param]
                        })
                else:
                    from statsmodels.formula.api import mixedlm
                    m = mixedlm(f"EAE_score ~ Glucose + {biomarker} + Phase_alt", sub, groups=sub['ID']).fit()
                    for param in m.params.index:
                        phase_sens_results.append({
                            'Model': 'MixedLM',
                            'Param': param,
                            'Coef': m.params[param],
                            'p_value': m.pvalues[param]
                        })
            except Exception as e:
                phase_sens_results.append({'Model': modeltype, 'Error': str(e)})
    pd.DataFrame(phase_sens_results).to_csv(os.path.join(eae_phase_dir, 'phase_sensitivity_results.csv'), index=False)

# Ensure numeric
for col in [
    'Glucose', 'EAE_score', 'Weight_%', 'WBCValue', 'LYMValue', 'MONValue', 'GRAValue', 'HGBValue', 'MCHValue',
    'MCHCValue', 'RBCValue', 'MCVValue', 'HCTValue', 'RDWValue', 'RDWaValue', 'PLTValue', 'MPVValue'
]:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce')

# Only keep rows with Group in colors
colors = {'HICT': 'red', 'NT': 'green'}
df = df[df['Group'].isin(colors.keys())]

# Get all unique terms for full x-axis
all_terms = sorted(df['Term'].dropna().unique())

fig, ax1 = plt.subplots(figsize=(10, 6))

for group in df['Group'].unique():
    group_df = df[df['Group'] == group].groupby('Term').mean(numeric_only=True).sort_index()
    group_df = group_df.reindex(all_terms)
    glucose_interp = group_df['Glucose'].interpolate()
    weight_interp = group_df[weight_col].interpolate()
    eae_interp = group_df['EAE_score'].interpolate()

    mask = (glucose_interp.index >= 2) & (glucose_interp.index <= 8)
    ax1.plot(glucose_interp.index[mask], glucose_interp[mask], color='black', linewidth=0.5, linestyle=':', zorder=1)
    ax1.plot(weight_interp.index[mask], weight_interp[mask], color='black', linewidth=0.5, linestyle=':', zorder=1)

    ax1.plot(group_df.index, group_df['Glucose'], marker='o', color=colors[group], label=f'{group} Glucose', zorder=2)
    ax1.plot(group_df.index, group_df[weight_col], marker='s', color=colors[group], linestyle='--', label=f'{group} Weight %', zorder=2)

ax1.set_xlabel("Term (Time)", fontsize=14)
ax1.set_ylabel("Glucose (mg/dL), Weight (%)", fontsize=14)

# EAE Score (right y-axis)
ax2 = ax1.twinx()
for group in df['Group'].unique():
    group_df = df[df['Group'] == group].groupby('Term').mean(numeric_only=True).sort_index()
    group_df = group_df.reindex(all_terms)
    eae_interp = group_df['EAE_score'].interpolate()
    mask = (eae_interp.index >= 2) & (eae_interp.index <= 8)
    ax2.plot(eae_interp.index[mask], eae_interp[mask], color='black', linewidth=0.5, linestyle=':', zorder=1)
    ax2.plot(group_df.index, group_df['EAE_score'], marker='^', color=colors[group], linestyle=':', label=f'{group} EAE Score', zorder=2)

ax2.set_ylabel("EAE Score", fontsize=14)
ax2.set_ylim(0, 4)

# Custom legend for black dotted line
custom_lines = [
    Line2D([0], [0], color='black', lw=1, linestyle=':', label='n/a (interpolated)')
]

# Combine legends
lines1, labels1 = ax1.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
all_lines = lines1 + lines2 + custom_lines
all_labels = labels1 + labels2 + ['n/a (interpolated)']
ax1.legend(all_lines, all_labels, fontsize=10, loc='upper left')

plt.title("Glucose, EAE Score, and Weight % vs Time (with dotted interpolated line, days 2-8)", fontsize=15)
plt.tight_layout()
plt.savefig(os.path.join(analysis_graphs_dir, "summary_plot.png"), dpi=300)
plt.close()

# --- Statistical analysis: t-test for glucose at each term ---
# --- Save t-test results for glucose at each term to a txt file ---
t_test_results = []
t_test_results.append("Statistical analysis of Glucose between groups at each Term:\n")
for term in all_terms:
    hict_vals = df[(df['Group'] == 'HICT') & (df['Term'] == term)]['Glucose'].dropna()
    nt_vals = df[(df['Group'] == 'NT') & (df['Term'] == term)]['Glucose'].dropna()
    if len(hict_vals) > 1 and len(nt_vals) > 1:
        stat, pval = ttest_ind(hict_vals, nt_vals, equal_var=False)
        t_test_results.append(f"Term {term}: t={stat:.2f}, p={pval:.4f} (HICT n={len(hict_vals)}, NT n={len(nt_vals)})\n")
    else:
        t_test_results.append(f"Term {term}: Not enough data for t-test (HICT n={len(hict_vals)}, NT n={len(nt_vals)})\n")

with open(os.path.join(analysis_graphs_dir, "glucose_ttest_by_term.txt"), "w") as f:
    f.writelines(t_test_results)
print("Glucose t-test results by term saved to analysis_graphs/glucose_ttest_by_term.txt")

# --- Save t-test results for Weight % at each term to a txt file ---
weightpct_ttest_results = []
weightpct_ttest_results.append("Statistical analysis of Weight % between groups at each Term:\n")
for term in all_terms:
    hict_vals = df[(df['Group'] == 'HICT') & (df['Term'] == term)][weight_col].dropna()
    nt_vals = df[(df['Group'] == 'NT') & (df['Term'] == term)][weight_col].dropna()
    if len(hict_vals) > 1 and len(nt_vals) > 1:
        stat, pval = ttest_ind(hict_vals, nt_vals, equal_var=False)
        weightpct_ttest_results.append(f"Term {term}: t={stat:.2f}, p={pval:.4f} (HICT n={len(hict_vals)}, NT n={len(nt_vals)})\n")
    else:
        weightpct_ttest_results.append(f"Term {term}: Not enough data for t-test (HICT n={len(hict_vals)}, NT n={len(nt_vals)})\n")

with open(os.path.join(analysis_graphs_dir, "weightpct_ttest_by_term.txt"), "w") as f:
    f.writelines(weightpct_ttest_results)
print("Weight % t-test results by term saved to analysis_graphs/weightpct_ttest_by_term.txt")

# --- FDR-corrected per-term t-test CSV outputs ---
from statsmodels.stats.multitest import multipletests
glucose_ttest_df = []
weightpct_ttest_df = []
for term in all_terms:
    hict_vals = df[(df['Group'] == 'HICT') & (df['Term'] == term)]['Glucose'].dropna()
    nt_vals = df[(df['Group'] == 'NT') & (df['Term'] == term)]['Glucose'].dropna()
    if len(hict_vals) > 1 and len(nt_vals) > 1:
        stat, pval = ttest_ind(hict_vals, nt_vals, equal_var=False)
        glucose_ttest_df.append({'Term': term, 't_value': stat, 'p_value': pval})
for term in all_terms:
    hict_vals = df[(df['Group'] == 'HICT') & (df['Term'] == term)][weight_col].dropna()
    nt_vals = df[(df['Group'] == 'NT') & (df['Term'] == term)][weight_col].dropna()
    if len(hict_vals) > 1 and len(nt_vals) > 1:
        stat, pval = ttest_ind(hict_vals, nt_vals, equal_var=False)
        weightpct_ttest_df.append({'Term': term, 't_value': stat, 'p_value': pval})
glucose_ttest_df = pd.DataFrame(glucose_ttest_df)
weightpct_ttest_df = pd.DataFrame(weightpct_ttest_df)
if not glucose_ttest_df.empty:
    _, pvals_fdr, _, _ = multipletests(glucose_ttest_df['p_value'], alpha=0.05, method='fdr_bh')
    glucose_ttest_df['p_FDR'] = pvals_fdr
    glucose_ttest_df.to_csv(os.path.join(analysis_graphs_dir, 'glucose_ttest_by_term.csv'), index=False)
if not weightpct_ttest_df.empty:
    _, pvals_fdr, _, _ = multipletests(weightpct_ttest_df['p_value'], alpha=0.05, method='fdr_bh')
    weightpct_ttest_df['p_FDR'] = pvals_fdr
    weightpct_ttest_df.to_csv(os.path.join(analysis_graphs_dir, 'weightpct_ttest_by_term.csv'), index=False)

# --- LMM Analysis and Visuals ---
blood_cols = [
    'WBCValue', 'LYMValue', 'MONValue', 'GRAValue', 'HGBValue', 'MCHValue', 'MCHCValue',
    'RBCValue', 'MCVValue', 'HCTValue', 'RDWValue', 'RDWaValue', 'PLTValue', 'MPVValue',
    'Glucose', 'EAE_score'
]
id_col = 'ID' if 'ID' in df.columns else df.columns[-1]

# Output directory for LMM plots and results

# === PRIMARY OUTCOMES DEFINITION ===
primary_outcomes = [
    'Glucose', 'EAE_score',
    'WBCValue', 'LYMValue', 'PLTValue', 'MPVValue', 'RDWValue'
]

# === PRIMARY LMMs: Term * Group interaction ===
primary_lmm_dir = os.path.join(master_folder, "primary_lmm")
os.makedirs(primary_lmm_dir, exist_ok=True)
primary_lmm_results = []
primary_lmm_warnings = []

for outcome in primary_outcomes:
    if outcome not in df.columns:
        continue
    lmm_df = df[['Term', 'Group', id_col, outcome]].dropna()
    if lmm_df[outcome].nunique() < 2 or lmm_df['Group'].nunique() < 2:
        continue
    try:
        model = mixedlm(f"{outcome} ~ Term * Group", lmm_df, groups=lmm_df[id_col])
        result = model.fit(method='nm', maxiter=200)
        params = result.params
        bse = result.bse
        pvals = result.pvalues
        ci = result.conf_int()
        for param in params.index:
            primary_lmm_results.append({
                "Outcome": outcome,
                "Param": param,
                "Coef": params[param],
                "SE": bse[param],
                "p_value": pvals[param],
                "CI_low": ci.loc[param, 0],
                "CI_high": ci.loc[param, 1]
            })
        if hasattr(result, 'mle_retvals') and 'converged' in result.mle_retvals and not result.mle_retvals['converged']:
            primary_lmm_warnings.append(f"{outcome}: did not converge")
    except Exception as e:
        primary_lmm_warnings.append(f"{outcome}: {str(e)}")

primary_lmm_df = pd.DataFrame(primary_lmm_results)

# === FDR correction for primary LMM fixed effects ===
from statsmodels.stats.multitest import multipletests
def fdr_column(df, param_substr, colname):
    mask = df['Param'].str.contains(param_substr, regex=False)
    pvals = df.loc[mask, 'p_value']
    if len(pvals) > 0:
        _, pvals_fdr, _, _ = multipletests(pvals, alpha=0.05, method='fdr_bh')
        df.loc[mask, colname] = pvals_fdr
    else:
        df[colname] = np.nan

# FDR for Term (includes Term and Term:Group)
fdr_column(primary_lmm_df, 'Term:', 'p_FDR_term_group')
fdr_column(primary_lmm_df, 'Term', 'p_FDR_term')
# FDR for Group (main effect only, not interaction)
fdr_column(primary_lmm_df, 'Group', 'p_FDR_group')

primary_lmm_df.to_csv(os.path.join(primary_lmm_dir, "primary_lmm_results.csv"), index=False)
with open(os.path.join(primary_lmm_dir, "primary_lmm_warnings.txt"), "w") as f:
    for w in primary_lmm_warnings:
        f.write(w + "\n")

# === Nonlinear time sensitivity analysis: Term as categorical ===
# Not used for primary conclusions; sensitivity only
termcat_results = []
for outcome in primary_outcomes:
    if outcome not in df.columns:
        continue
    lmm_df = df[['Term', 'Group', id_col, outcome]].dropna()
    if lmm_df[outcome].nunique() < 2 or lmm_df['Group'].nunique() < 2:
        continue
    lmm_df['Term_cat'] = lmm_df['Term'].astype('category')
    try:
        model = mixedlm(f"{outcome} ~ C(Term_cat) * Group", lmm_df, groups=lmm_df[id_col])
        result = model.fit(method='nm', maxiter=200)
        # Save p-values for Group and interaction
        p_group = result.pvalues.get('Group[T.HICT]', np.nan)
        p_inter = None
        for param in result.pvalues.index:
            if 'C(Term_cat):Group' in param:
                p_inter = result.pvalues[param]
                break
        termcat_results.append({
            'Outcome': outcome,
            'p_Group': p_group,
            'p_TermCat_Group_interaction': p_inter
        })
    except Exception as e:
        termcat_results.append({
            'Outcome': outcome,
            'Error': str(e)
        })
with open(os.path.join(primary_lmm_dir, "primary_lmm_term_categorical.txt"), "w") as f:
    f.write("Nonlinear time sensitivity (Term as categorical); not used for primary conclusions\n")
    for res in termcat_results:
        f.write(str(res) + "\n")

# === SECONDARY/EXPLORATORY LMMs ===
# All other outcomes (not in primary_outcomes) are analyzed as exploratory.
secondary_lmm_results = []
for var in blood_cols:
    if var not in df.columns or var in primary_outcomes:
        continue
    lmm_df = df[['Term', 'Group', id_col, var]].dropna()
    if lmm_df[var].nunique() < 2 or lmm_df['Group'].nunique() < 2:
        continue
    try:
        model = mixedlm(f"{var} ~ Term + Group", lmm_df, groups=lmm_df[id_col])
        result = model.fit(method='nm', maxiter=200)
        secondary_lmm_results.append(f"Exploratory LMM for {var}:\n{result.summary()}\n")
    except Exception as e:
        secondary_lmm_results.append(f"Exploratory LMM for {var}:\nLMM failed: {e}\n")

with open(os.path.join(master_folder, "secondary_lmm_results.txt"), "w") as f:
    for res in secondary_lmm_results:
        f.write(res)
        f.write("\n" + "="*80 + "\n")

# === LMM Visualizations (unchanged, for all outcomes) ===
for var in blood_cols:
    if var not in df.columns:
        continue
    lmm_df = df[['Term', 'Group', id_col, var]].dropna()
    if lmm_df[var].nunique() < 2 or lmm_df['Group'].nunique() < 2:
        continue
    # Visualize: individual mice over time, colored by group (full size)
    plt.figure(figsize=(16, 8))
    for group in lmm_df['Group'].unique():
        group_color = colors.get(group, 'gray')
        group_mice = lmm_df[lmm_df['Group'] == group][id_col].unique()
        for mouse in group_mice:
            mouse_data = lmm_df[(lmm_df['Group'] == group) & (lmm_df[id_col] == mouse)]
            plt.plot(mouse_data['Term'], mouse_data[var], color=group_color, alpha=0.4, linewidth=2, label=f"{group} Mouse" if mouse == group_mice[0] else None)
        group_stats = lmm_df[lmm_df['Group'] == group].groupby('Term')[var].agg(['mean', 'std']).reset_index()
        plt.plot(group_stats['Term'], group_stats['mean'], color=group_color, linewidth=4, label=f"{group} Mean")
        plt.fill_between(group_stats['Term'], group_stats['mean']-group_stats['std'], group_stats['mean']+group_stats['std'], color=group_color, alpha=0.2, label=f"{group} ±SD")
    plt.title(f"{var} over Time by Mouse and Group (Mean ± SD)")
    plt.xlabel("Term (Time)")
    plt.ylabel(var)
    plt.legend()
    plt.tight_layout()
    plt.savefig(os.path.join(lmm_plots_dir, f"{var}_individual_mice.png"), dpi=300)
    plt.close()

    # Visualize: group means with shaded error zones (std)
    plt.figure(figsize=(16, 8))
    for group in lmm_df['Group'].unique():
        group_color = colors.get(group, 'gray')
        group_stats = lmm_df[lmm_df['Group'] == group].groupby('Term')[var].agg(['mean', 'std']).reset_index()
        plt.plot(group_stats['Term'], group_stats['mean'], color=group_color, marker='o', label=f"{group} Mean")
        plt.fill_between(group_stats['Term'], group_stats['mean']-group_stats['std'], group_stats['mean']+group_stats['std'], color=group_color, alpha=0.2, label=f"{group} ±SD")
    plt.title(f"{var} Group Means over Time (Mean ± SD)")
    plt.xlabel("Term (Time)")
    plt.ylabel(var)
    plt.legend()
    plt.tight_layout()
    plt.savefig(os.path.join(lmm_plots_dir, f"{var}_group_means.png"), dpi=300)
    plt.close()

# --- EAE Phase Analysis: Onset vs Recovery ---
# --- New Analysis Folders ---

# Ensure master_folder is defined before use
master_folder = "analysis_master_folder"
lm_interaction_dir = os.path.join(master_folder, "lm_interaction")
mixed_effects_dir = os.path.join(master_folder, "mixed_effects")
os.makedirs(master_folder, exist_ok=True)
os.makedirs(lm_interaction_dir, exist_ok=True)
os.makedirs(mixed_effects_dir, exist_ok=True)

# --- Linear Model with Interaction ---
lm_interaction_results = []
for biomarker in bloodtypes:
    biomarker_col = f"{biomarker}Value"
    if biomarker_col not in df.columns:
        continue
    # Ensure all relevant columns are present and clean
    df_lm = df[[biomarker_col, 'Glucose', 'Group', 'Phase', 'EAE_score']].dropna()
    df_lm['Group'] = df_lm['Group'].astype('category')
    df_lm['Phase'] = df_lm['Phase'].astype('category')
    formula = f"EAE_score ~ {biomarker_col} + Glucose + Group + Phase + {biomarker_col}:Group + {biomarker_col}:Phase"
    model = smf.ols(formula, data=df_lm).fit()
    summary_path = os.path.join(lm_interaction_dir, f"{biomarker}_lm_interaction_summary.txt")
    with open(summary_path, "w") as f:
        f.write(model.summary().as_text())
    # Save coefficients and p-values
    for param in model.params.index:
        ci = model.conf_int().loc[param].tolist()
        lm_interaction_results.append({
            "Biomarker": biomarker,
            "Parameter": param,
            "Coef": model.params[param],
            "p_value": model.pvalues[param],
            "CI_low": ci[0],
            "CI_high": ci[1]
        })
lm_interaction_df = pd.DataFrame(lm_interaction_results)
lm_interaction_df.to_csv(os.path.join(lm_interaction_dir, "lm_interaction_results.csv"), index=False)

# --- Mixed Effects Model ---
from statsmodels.formula.api import mixedlm
mixed_effects_results = []
for biomarker in bloodtypes:
    biomarker_col = f"{biomarker}Value"
    if biomarker_col not in df.columns or 'ID' not in df.columns:
        continue
    df_me = df[[biomarker_col, 'Glucose', 'Group', 'EAE_score', 'ID']].dropna()
    df_me['Group'] = df_me['Group'].astype('category')
    formula = f"EAE_score ~ {biomarker_col} * Group + Glucose"
    try:
        model = mixedlm(formula, df_me, groups=df_me['ID']).fit()
        summary_path = os.path.join(mixed_effects_dir, f"{biomarker}_mixed_effects_summary.txt")
        with open(summary_path, "w") as f:
            f.write(model.summary().as_text())
        # Save coefficients and p-values
        for param in model.params.index:
            ci = model.conf_int().loc[param].tolist() if param in model.conf_int().index else [np.nan, np.nan]
            mixed_effects_results.append({
                "Biomarker": biomarker,
                "Parameter": param,
                "Coef": model.params[param],
                "p_value": model.pvalues[param],
                "CI_low": ci[0],
                "CI_high": ci[1]
            })
    except Exception as e:
        error_path = os.path.join(mixed_effects_dir, f"{biomarker}_mixed_effects_error.txt")
        with open(error_path, "w") as f:
            f.write(str(e))
mixed_effects_df = pd.DataFrame(mixed_effects_results)
mixed_effects_df.to_csv(os.path.join(mixed_effects_dir, "mixed_effects_results.csv"), index=False)
import os
import numpy as np
from scipy.stats import sem, t
from mpl_toolkits.mplot3d import Axes3D


# Create master folder and subfolders
master_folder = "analysis_master_folder"
eae_phase_dir = os.path.join(master_folder, "eae_phase_analysis")
eae_phase_graph_dir = os.path.join(master_folder, "eae_phase_graphs")
biomarker_eae_graph_dir = os.path.join(master_folder, "biomarker_eae_graphs")
analysis_graphs_dir = os.path.join(master_folder, "analysis_graphs")
lmm_plots_dir = os.path.join(master_folder, "lmm_plots")
os.makedirs(master_folder, exist_ok=True)
os.makedirs(eae_phase_dir, exist_ok=True)
os.makedirs(eae_phase_graph_dir, exist_ok=True)
os.makedirs(biomarker_eae_graph_dir, exist_ok=True)
os.makedirs(analysis_graphs_dir, exist_ok=True)
os.makedirs(lmm_plots_dir, exist_ok=True)

def mean_ci(data, confidence=0.95):
    data = np.array(data.dropna())
    n = len(data)
    if n == 0:
        return np.nan, (np.nan, np.nan)
    m = np.mean(data)
    se = sem(data)
    h = se * t.ppf((1 + confidence) / 2., n-1) if n > 1 else 0
    return m, (m-h, m+h)

# Detect peak EAE for each mouse
peak_times = {}
for mouse in df['ID'].unique():
    mouse_df = df[df['ID'] == mouse]
    if not mouse_df.empty:
        peak_idx = mouse_df['EAE_score'].idxmax()
        peak_time = mouse_df.loc[peak_idx, 'Term']
        peak_times[mouse] = peak_time

df['Phase'] = df.apply(lambda row: 'onset' if row['Term'] <= peak_times.get(row['ID'], np.inf) else 'recovery', axis=1)

# Prepare for plotting
group_colors = {'NT': 'green', 'HICT': 'red'}
phase_styles = {'onset': 'solid', 'recovery': 'dashed'}

# Plot EAE lines for each group/phase
plt.figure(figsize=(12, 8))
for group in ['NT', 'HICT']:
    for phase in ['baseline', 'presymptomatic', 'onset', 'recovery']:
        sub = df[(df['Group'] == group) & (df['Phase'] == phase)]
        if sub.empty:
            continue
        means = sub.groupby('Term')['EAE_score'].mean()
        cis = sub.groupby('Term')['EAE_score'].apply(lambda x: mean_ci(x)[1])
        lower = means.index.map(lambda t: cis[t][0])
        upper = means.index.map(lambda t: cis[t][1])
        plt.plot(means.index, means.values, color=group_colors[group], linestyle='-' if phase=='onset' else '--', label=f'{group} {phase}')
        plt.fill_between(means.index, lower, upper, color=group_colors[group], alpha=0.2)
plt.xlabel('Term (Time)')
plt.ylabel('EAE Score')
plt.title('EAE Score Trajectory: Onset vs Recovery')
plt.legend()
plt.tight_layout()
plt.savefig(os.path.join(eae_phase_graph_dir, "EAE_onset_recovery.png"))
plt.close()

# Multivariate analysis: Glucose, each biomarker, EAE severity
import statsmodels.formula.api as smf
multi_results = []
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.cm as cm
compare_results = []  # For group comparison results
for biomarker in bloodtypes:
    biomarker_col = f"{biomarker}Value"
    if biomarker_col not in df.columns:
        continue

    # --- Split by onset and recovery, plot both groups for each phase, and compare groups ---
    for phase in ['onset', 'recovery']:
        for group in ['NT', 'HICT']:
            sub = df[(df['Group'] == group) & (df['Phase'] == phase)]
            if sub[[biomarker_col, 'Glucose', 'EAE_score']].dropna().shape[0] < 3:
                continue
            # Multivariate regression: biomarker vs glucose vs eae score
            model = smf.ols(f'EAE_score ~ Glucose + {biomarker_col}', data=sub).fit()
            # 3D plot
            fig = plt.figure(figsize=(12, 10))
            ax = fig.add_subplot(111, projection='3d')
            x = sub['Glucose']
            y = sub[biomarker_col]
            z = sub['EAE_score']
            ax.scatter(x, y, z, color=colors[group], alpha=0.3, label=f'{group} data')
            xx, yy = np.meshgrid(np.linspace(x.min(), x.max(), 20), np.linspace(y.min(), y.max(), 20))
            zz = model.params['Intercept'] + model.params.get('Glucose', 0)*xx + model.params.get(biomarker_col, 0)*yy
            ax.plot_surface(xx, yy, zz, color=colors[group], alpha=0.4, label=f'{group} plane')
            ax.set_xlabel('Glucose')
            ax.set_ylabel(biomarker)
            ax.set_zlabel('EAE Score')
            ax.set_title(f'{biomarker} vs Glucose vs EAE ({group}, {phase})')
            ax.legend()
            plt.tight_layout()
            plt.savefig(os.path.join(eae_phase_graph_dir, f'{biomarker}_{group}_{phase}_3D.png'))
            plt.close()

        # --- Group comparison: fit model with interaction terms ---
        sub_all = df[df['Phase'] == phase].copy()
        if sub_all[[biomarker_col, 'Glucose', 'EAE_score', 'Group']].dropna().shape[0] < 6:
            continue
        # Ensure Group is categorical with NT as reference
        sub_all['Group'] = pd.Categorical(sub_all['Group'], categories=['NT', 'HICT'])
        try:
            formula = f"EAE_score ~ Glucose + {biomarker_col} + Group + Glucose:Group + {biomarker_col}:Group"
            model = smf.ols(formula, data=sub_all).fit()
            # Extract p-values for interaction terms
            p_glucose_inter = model.pvalues.get('Glucose:Group[T.HICT]', np.nan)
            p_biomarker_inter = model.pvalues.get(f'{biomarker_col}:Group[T.HICT]', np.nan)
            coef_glucose_inter = model.params.get('Glucose:Group[T.HICT]', np.nan)
            coef_biomarker_inter = model.params.get(f'{biomarker_col}:Group[T.HICT]', np.nan)
            compare_results.append({
                'Biomarker': biomarker,
                'Phase': phase,
                'Glucose_interaction_coef': coef_glucose_inter,
                'Glucose_interaction_p': p_glucose_inter,
                'Biomarker_interaction_coef': coef_biomarker_inter,
                'Biomarker_interaction_p': p_biomarker_inter,
                'N': sub_all.shape[0]
            })
        except Exception as e:
            compare_results.append({
                'Biomarker': biomarker,
                'Phase': phase,
                'Glucose_interaction_coef': np.nan,
                'Glucose_interaction_p': np.nan,
                'Biomarker_interaction_coef': np.nan,
                'Biomarker_interaction_p': np.nan,
                'N': sub_all.shape[0],
                'Error': str(e)
            })

    # Continue with previous per-group/phase analysis and plots
    for group in ['NT', 'HICT', 'all']:
        if group == 'all':
            sub = df.copy()
        else:
            sub = df[df['Group'] == group]
        for phase in ['baseline', 'presymptomatic', 'onset', 'recovery', 'all']:
            if phase != 'all':
                sub_phase = sub[sub['Phase'] == phase]
            else:
                sub_phase = sub
            if sub_phase[[biomarker_col, 'Glucose', 'EAE_score']].dropna().shape[0] < 3:
                continue
            # Multivariate regression
            model = smf.ols(f'EAE_score ~ Glucose + {biomarker_col}', data=sub_phase).fit()
            multi_results.append({
                'Biomarker': biomarker,
                'Group': group,
                'Phase': phase,
                'N': sub_phase.shape[0],
                'Glucose_coef': model.params.get('Glucose', np.nan),
                'Biomarker_coef': model.params.get(biomarker_col, np.nan),
                'Intercept': model.params.get('Intercept', np.nan),
                'R2': model.rsquared,
                'p_Glucose': model.pvalues.get('Glucose', np.nan),
                'p_Biomarker': model.pvalues.get(biomarker_col, np.nan),
                'p_Intercept': model.pvalues.get('Intercept', np.nan)
            })
            # 3D plot
            fig = plt.figure(figsize=(10, 8))
            ax = fig.add_subplot(111, projection='3d')
            x = sub_phase['Glucose']
            y = sub_phase[biomarker_col]
            z = sub_phase['EAE_score']
            ax.scatter(x, y, z, c=z, cmap=cm.viridis, alpha=0.7)
            ax.set_xlabel('Glucose')
            ax.set_ylabel(biomarker)
            ax.set_zlabel('EAE Score')
            ax.set_title(f'{biomarker} vs Glucose vs EAE ({group}, {phase})')
            # Fit plane for regression
            if len(x.dropna()) > 2 and len(y.dropna()) > 2:
                xx, yy = np.meshgrid(np.linspace(x.min(), x.max(), 20), np.linspace(y.min(), y.max(), 20))
                zz = model.params['Intercept'] + model.params.get('Glucose', 0)*xx + model.params.get(biomarker_col, 0)*yy
                ax.plot_surface(xx, yy, zz, color='orange', alpha=0.3)
            plt.tight_layout()
            plt.savefig(f"{eae_phase_graph_dir}/{biomarker}_{group}_{phase}_3D.png")
            plt.close()

# Save statistical values to CSV
import pandas as pd
from statsmodels.stats.multitest import multipletests

# FDR correction for regression p-values
multi_pvals = [r['p_Glucose'] for r in multi_results if not pd.isnull(r['p_Glucose'])]
biomarker_pvals = [r['p_Biomarker'] for r in multi_results if not pd.isnull(r['p_Biomarker'])]
rej_glu, pvals_glu_fdr, _, _ = multipletests(multi_pvals, alpha=0.05, method='fdr_bh') if multi_pvals else ([], [], [], [])
rej_bio, pvals_bio_fdr, _, _ = multipletests(biomarker_pvals, alpha=0.05, method='fdr_bh') if biomarker_pvals else ([], [], [], [])

# Add FDR p-values and 95% CIs for regression coefficients
for i, r in enumerate(multi_results):
    # FDR p-values
    if not pd.isnull(r['p_Glucose']):
        r['p_Glucose_FDR'] = pvals_glu_fdr[i] if i < len(pvals_glu_fdr) else r['p_Glucose']
    if not pd.isnull(r['p_Biomarker']):
        r['p_Biomarker_FDR'] = pvals_bio_fdr[i] if i < len(pvals_bio_fdr) else r['p_Biomarker']
    # 95% CI for regression coefficients
    # These are available from the model.conf_int() in statsmodels, but here we only have the values
    # To add, you would need to save them during model fitting. For now, add placeholders.
    r['Glucose_CI_low'] = np.nan
    r['Glucose_CI_high'] = np.nan
    r['Biomarker_CI_low'] = np.nan
    r['Biomarker_CI_high'] = np.nan

multi_results_df = pd.DataFrame(multi_results)
multi_results_df.to_csv(os.path.join(eae_phase_dir, "multivariate_stats.csv"), index=False)
print("EAE phase analysis and multivariate results saved.")

# FDR correction for group comparison p-values
gc_pvals_glu = [r['Glucose_interaction_p'] for r in compare_results if not pd.isnull(r['Glucose_interaction_p'])]
gc_pvals_bio = [r['Biomarker_interaction_p'] for r in compare_results if not pd.isnull(r['Biomarker_interaction_p'])]
rej_gc_glu, pvals_gc_glu_fdr, _, _ = multipletests(gc_pvals_glu, alpha=0.05, method='fdr_bh') if gc_pvals_glu else ([], [], [], [])
rej_gc_bio, pvals_gc_bio_fdr, _, _ = multipletests(gc_pvals_bio, alpha=0.05, method='fdr_bh') if gc_pvals_bio else ([], [], [], [])

for i, r in enumerate(compare_results):
    if not pd.isnull(r['Glucose_interaction_p']):
        r['Glucose_interaction_p_FDR'] = pvals_gc_glu_fdr[i] if i < len(pvals_gc_glu_fdr) else r['Glucose_interaction_p']
    if not pd.isnull(r['Biomarker_interaction_p']):
        r['Biomarker_interaction_p_FDR'] = pvals_gc_bio_fdr[i] if i < len(pvals_gc_bio_fdr) else r['Biomarker_interaction_p']

compare_results_df = pd.DataFrame(compare_results)
compare_results_df.to_csv(os.path.join(eae_phase_dir, "group_comparison_stats.csv"), index=False)
print("Group comparison results (NT vs HICT for each biomarker and phase) saved to eae_phase_analysis/group_comparison_stats.csv.")

# --- Correlation of Blood Biomarkers with EAE Score ---

os.makedirs(biomarker_eae_graph_dir, exist_ok=True)  # Ensure output folder exists

# --- Correlation of Blood Biomarkers and Glucose with EAE Score ---
biomarker_eae_results = []
biomarker_list = bloodtypes + ['Glucose']
for bloodtype in biomarker_list:
    if bloodtype == 'Glucose':
        biomarker_col = 'Glucose'
        biomarker_label = 'Glucose'
    else:
        biomarker_col = f"{bloodtype}Value"
        biomarker_label = bloodtype
    if biomarker_col not in df.columns or 'EAE_score' not in df.columns:
        continue
    # Ensure numeric
    df[biomarker_col] = pd.to_numeric(df[biomarker_col], errors="coerce")
    df['EAE_score'] = pd.to_numeric(df['EAE_score'], errors="coerce")
    x = df[biomarker_col]
    y = df['EAE_score']
    mask = x.notna() & y.notna()
    corr, pval, method = choose_corr(x, y)
    biomarker_eae_results.append({
        "Biomarker": biomarker_label,
        "Method": method,
        "Correlation": corr,
        "p_value": pval,
        "N": mask.sum()
    })
    # Plot and save scatter plot
    plt.figure(figsize=(8, 6))
    plt.scatter(x[mask], y[mask], alpha=0.7)
    plt.xlabel(f"{biomarker_label} Value")
    plt.ylabel("EAE Score")
    plt.title(f"{biomarker_label} vs EAE Score\nMethod: {method}")
    # Regression line if enough data
    if mask.sum() > 1:
        X = sm.add_constant(x[mask])
        model = sm.OLS(y[mask], X).fit()
        pred = model.get_prediction(X)
        mean_pred = pred.predicted_mean
        sort_idx = np.argsort(x[mask])
        plt.plot(x[mask].values[sort_idx], mean_pred[sort_idx], color='red', linestyle='--', label='Fit')
        plt.legend()
    plt.tight_layout()
    plt.savefig(os.path.join(biomarker_eae_graph_dir, f"{biomarker_label}_vs_EAE_score.png"))
    plt.close()

import pandas as pd
biomarker_eae_df = pd.DataFrame(biomarker_eae_results)

# FDR correction for biomarker-EAE correlations
if not biomarker_eae_df.empty:
    from statsmodels.stats.multitest import multipletests
    _, pvals_fdr, _, _ = multipletests(biomarker_eae_df['p_value'], alpha=0.05, method='fdr_bh')
    biomarker_eae_df['p_FDR'] = pvals_fdr
biomarker_eae_df.to_csv(os.path.join(biomarker_eae_graph_dir, "biomarker_eae_correlation.csv"), index=False)
print("Blood biomarker vs EAE score correlations saved to biomarker_eae_graphs/biomarker_eae_correlation.csv")
print("Graphs saved to biomarker_eae_graphs folder.")
